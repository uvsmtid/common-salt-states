<?xml version='1.0' encoding='UTF-8'?>
<project>

  {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import common_job_configuration with context %}
  {{ common_job_configuration(job_config, job_environ) }}

  <builders>

    {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import copy_artifacts with context %}
    {{ copy_artifacts(job_config, job_environ) }}

    <hudson.tasks.Shell>
      <command>

        {% from 'common/libs/host_config_queries.sls' import get_system_host_primary_user_posix_home with context %}

        {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import locate_dynamic_build_descriptor with context %}
        {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import update_dynamic_build_descriptor with context %}

        {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import common_build_script_header with context %}
        {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import common_build_script_footer with context %}

        #######################################################################
        # Script header

        {{ common_build_script_header(job_config, job_environ) }}

        #######################################################################
        # Locate dynamic build descriptor.

        # NOTE: When we recover, we do not need to verify
        #       initial dyn build desc. In fact, it cannot be verified
        #       as this is either standalone (no initial dyn build desc)
        #       or belongs to a new build (with different dyn build desc).

        {{ locate_dynamic_build_descriptor(job_config, job_environ, check_init_dyn_build_desc = False) }}

        # IMPORTANT: We need to update dynamic bulid descriptor
        #            for the next job in the pipeline now (as there is
        #            no more updates of dyn build desc within current
        #            pipeline) to pass the info generated in the jobs before.
        {{ update_dynamic_build_descriptor(job_config, job_environ) }}

        # Detect if recovery is needed from the previous build.
        if [ ! -f "${RECOVERY_DYN_BUILD_DESC_PATH}" ]
        then
            # No recovery dynamic build descriptor available from
            # the previous build - nothing to do.
            echo "No need to recover from the previous build".

            # Set build unstable.
            # See: http://stackoverflow.com/a/8822743/441652
            eval "${JENKINS_CLI_TOOL_INVOKE_STRING} set-build-result unstable"

            exit 0
        fi

        # Save recovery build descriptor in the one used by the job.
        cp "${RECOVERY_DYN_BUILD_DESC_PATH}" "${JOB_DYN_BUILD_DESC_PATH}"

        #######################################################################
        # Normally, there should not be any changes or untracked files
        # as they are either ignored (by .gitignore) or
        # committed during the build pipeline.
        # Before proceeding with recovery, check if there are any local
        # changes or untracked files and stash them.

        {% for repo_name in pillar['system_features']['deploy_environment_sources']['source_repositories'].keys() %}
        {% set repo_config = pillar['system_features']['deploy_environment_sources']['source_repositories'][repo_name]['git'] %}
        REPO_PATH="{{ get_system_host_primary_user_posix_home(repo_config['source_system_host']) }}/{{ repo_config['origin_uri_ssh_path'] }}"

        cd "${REPO_PATH}"
        if ! git diff-index --ignore-submodules=dirty --exit-code HEAD
        then
            git stash

            # Set job status to failed (but don't fail now, restore first)
            # in order to highlight stashed changes.
            JOB_STATUS='failed'
        fi

        cd -
        {% endfor %}

        #######################################################################
        # Switch back to initial branches.

        # NOTE: We assume that repository is available
        #       locally on Jenkins slave.

        {% for repo_name in pillar['system_features']['deploy_environment_sources']['source_repositories'].keys() %}
        {% set repo_config = pillar['system_features']['deploy_environment_sources']['source_repositories'][repo_name]['git'] %}
        REPO_PATH="{{ get_system_host_primary_user_posix_home(repo_config['source_system_host']) }}/{{ repo_config['origin_uri_ssh_path'] }}"

        cd "${REPO_PATH}"
        CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
        # HEAD value means that repository is at detached head.
        test "${CURRENT_BRANCH}" != "HEAD"
        cd -

        INITIAL_BRANCH="$(python ${KEY_GETTER_PYTHON_SCRIPT} ${JOB_DYN_BUILD_DESC_PATH} "initial_branches:{{ repo_name }}")"
        BUILD_BRANCH="$(python ${KEY_GETTER_PYTHON_SCRIPT} ${JOB_DYN_BUILD_DESC_PATH} "build_branches:{{ repo_name }}")"

        # Current branch and build branch are normally the same at this point.
        # However, allow it to be different if current branch is
        # switched back to initial branch (possibly manually,
        # possibly by this job, or... it should not be a problem).
        # The main point is to find build branch (i.g. to make sure that
        # the build actually happend and restore uncommited files).
        if [ "${CURRENT_BRANCH}" != "${BUILD_BRANCH}" ]
        then

            # This is already suspicious.
            JOB_STATUS='unstable'

            if [ "${CURRENT_BRANCH}" != "${INITIAL_BRANCH}" ]
            then
                echo "${CURRENT_BRANCH} != ${BUILD_BRANCH} != ${INITIAL_BRANCH}"
                exit 1
            fi
        fi

        cd "${REPO_PATH}"
        git checkout "${INITIAL_BRANCH}"
        cd -

        {% endfor %}

        #######################################################################
        # Restore uncommitted local content to the conditions
        # they were at the begining of the build pipeline.
        # NOTE: This does not apply to repos of `build_history_role`.

        {% for repo_name in pillar['system_features']['deploy_environment_sources']['source_repositories'].keys() %}
        {% set repo_config = pillar['system_features']['deploy_environment_sources']['source_repositories'][repo_name]['git'] %}
        REPO_PATH="{{ get_system_host_primary_user_posix_home(repo_config['source_system_host']) }}/{{ repo_config['origin_uri_ssh_path'] }}"

        cd "${REPO_PATH}"
        CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
        # HEAD value means that repository is at detached head.
        test "${CURRENT_BRANCH}" != "HEAD"
        cd -

        INITIAL_BRANCH="$(python ${KEY_GETTER_PYTHON_SCRIPT} ${JOB_DYN_BUILD_DESC_PATH} "initial_branches:{{ repo_name }}")"
        INITIAL_COMMIT_ID="$(python ${KEY_GETTER_PYTHON_SCRIPT} ${JOB_DYN_BUILD_DESC_PATH} "initial_commit_ids:{{ repo_name }}")"
        test "${CURRENT_BRANCH}" == "${INITIAL_BRANCH}"

        {% if repo_name in pillar['system_features']['deploy_environment_sources']['repository_roles']['build_history_role'] %}

        # NOTE: Build branches in `build_history_role` repository should not
        #       be recovered - they are meant to contain the build history
        #       as it was captured. The `build_history_role` repository
        #       should only be switched to its original branch.
        # NOTE: There is also nothing to be recovered.
        #       The `build_history_role` repository is required to be
        #       clean at the start of the pipeline.

        {% else %}

        RESTORE_POINT_COMMIT="$(python ${KEY_GETTER_PYTHON_SCRIPT} ${JOB_DYN_BUILD_DESC_PATH} "restore_point_commit_ids:{{ repo_name }}" "NOT_AVAILABLE")"

        cd "${REPO_PATH}"

        # The case of unavailable restore point may happen
        # when previous `init_pipeline` failed even before preparation
        # to making any changes.
        if [ "${RESTORE_POINT_COMMIT}" != "NOT_AVAILABLE" ]
        then

            # This step restores all local changes committed at the beginning.
            git checkout "${RESTORE_POINT_COMMIT}"

        else

            # This is rather unexpected, but not critical.
            JOB_STATUS='unstable'

        fi

        # This step resets HEAD to the commit before the beginning
        # while leaving all local files as they are at restore point.
        # We cannot simply checkout the branch as this would also set
        # local files into initial commits instead of restore point.
        git reset "${INITIAL_COMMIT_ID}"

        # This step moves away from detached HEAD to specified branch.
        # All modifications to local files produced by checking out
        # restore point and resetting to initial commit are
        # left untouched ("rebased" on top of initial branch).
        git checkout "${INITIAL_BRANCH}"

        cd -

        {% endif %}

        {% endfor %}

        #######################################################################
        # Remove all build branches.
        # NOTE: This does not apply to repos of `build_history_role`.

        # TODO: This better be done after promotion (which causes tagging).

        # TODO: In order to use `REMOVE_BUILD_BRANCHES_AFTER_PIPELINE_COMPLETION`
        #       env var, it must be set in properties file for this job.
        #       If this job is run as a standalone one (not part of
        #       pipeline build), the properties should be restored from
        #       dynamic build descriptor (because this variable is only
        #       set by user in the first job of the pipeline).
        REMOVE_BUILD_BRANCHES_AFTER_PIPELINE_COMPLETION="$(python ${KEY_GETTER_PYTHON_SCRIPT} ${JOB_DYN_BUILD_DESC_PATH} "build_parameters:REMOVE_BUILD_BRANCHES_AFTER_PIPELINE_COMPLETION")"
        if [ "${REMOVE_BUILD_BRANCHES_AFTER_PIPELINE_COMPLETION}" == "true" ]
        then

            {% for repo_name in pillar['system_features']['deploy_environment_sources']['source_repositories'].keys() %}
            {% set repo_config = pillar['system_features']['deploy_environment_sources']['source_repositories'][repo_name]['git'] %}
            REPO_PATH="{{ get_system_host_primary_user_posix_home(repo_config['source_system_host']) }}/{{ repo_config['origin_uri_ssh_path'] }}"

            cd "${REPO_PATH}"
            CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
            # HEAD value means that repository is at detached head.
            test "${CURRENT_BRANCH}" != "HEAD"
            cd -

            INITIAL_BRANCH="$(python ${KEY_GETTER_PYTHON_SCRIPT} ${JOB_DYN_BUILD_DESC_PATH} "initial_branches:{{ repo_name }}")"
            BUILD_BRANCH="$(python ${KEY_GETTER_PYTHON_SCRIPT} ${JOB_DYN_BUILD_DESC_PATH} "build_branches:{{ repo_name }}")"
            test "${CURRENT_BRANCH}" == "${INITIAL_BRANCH}"

            {% if repo_name in pillar['system_features']['deploy_environment_sources']['repository_roles']['build_history_role'] %}

            # NOTE: Build branches in `build_history_role` repository should not
            #       be removed. In fact, build branches should be removed
            #       everywhere unconditionally except `build_history_role`
            #       repository. There is even a need for a job which
            #       restores build branches as they were from
            #       `build_history_role` repository.

            {% else %}

            cd "${REPO_PATH}"
            # We need to force the deletion because branches may contain
            # unmerges changes - pipeline designed so that changes are saved.
            # Even if forced command fails, let's continue and indicate
            # cleanup as unstable - the old build branch leftover
            # is not critical.
            set +e
            git branch -vv -D "${BUILD_BRANCH}"
            RET_VAL="${?}"
            set -e
            if [ "${RET_VAL}" != "0" ]
            then
                JOB_STATUS='unstable'
            fi
            cd -

            {% endif %}

            {% endfor %}

        fi

        #######################################################################
        # Update dynamic build descriptor.

        {{ update_dynamic_build_descriptor(job_config, job_environ) }}

        # The purpose of this job is to indicate to itself (or its clones)
        # that all changes made to set up environment for the previous build
        # are reverted. The indication of this is done by existence (or not)
        # of the recovery build descriptor.
        # Remove it to inidcate that everything is reset.
        rm "${RECOVERY_DYN_BUILD_DESC_PATH}"

        #######################################################################
        # Script footer

        {{ common_build_script_footer(job_config, job_environ) }}

        #######################################################################

      </command>
    </hudson.tasks.Shell>
  </builders>

  <publishers>

    {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import parameterized_job_triggers_macro with context %}
    {{ parameterized_job_triggers_macro(job_config, job_environ) }}

  </publishers>

  <buildWrappers/>

</project>

