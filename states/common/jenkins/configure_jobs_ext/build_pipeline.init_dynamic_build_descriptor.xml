<?xml version='1.0' encoding='UTF-8'?>
<project>

  {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import common_job_configuration with context %}
  {{ common_job_configuration(job_config, job_environ) }}

  <builders>

    {#
    DISABLE copying artifacts because it is the very first job in the pipeline.
    {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import copy_artifacts with context %}
    {{ copy_artifacts(job_config, job_environ) }}
    #}

    <hudson.tasks.Shell>
      <command>

        set -e
        set -u

        {% if 'skip_script_execution' in job_config and job_config['skip_script_execution'] %}
        exit 0
        {% endif %}

        #######################################################################
        # Locate dynamic build descriptor.

        {% from 'common/libs/host_config_queries.sls' import get_system_host_primary_user_posix_home with context %}

        # Get location of dynamic build descriptor (which is in pillar).
        {% set project_name = pillar['project_name'] %}
        {% if pillar['is_generic_profile'] %}
        {% set repo_config = pillar['system_features']['deploy_environment_sources']['source_repositories'][project_name + '-salt-states']['git'] %}
        {% else %}
        {% set repo_config = pillar['system_features']['deploy_environment_sources']['source_repositories'][project_name + '-salt-pillars']['git'] %}
        {% endif %}
        DYN_BUILD_DESC_PATH='{{ get_system_host_primary_user_posix_home(repo_config['source_system_host']) }}/{{ repo_config['origin_uri_ssh_path'] }}/pillars/profile/dynamic_build_descriptor.yaml'
        # Make sure file exists.
        ls -lrt ${DYN_BUILD_DESC_PATH}

        # Now, do not touch this file right now.
        # Let the job detect changes first (avoiding changes caused by itself).
        # Instead, use temporary file and overwrite exiting by the contents
        # of the temporary at the end of the job.
        ORIG_DYN_BUILD_DESC_PATH="${DYN_BUILD_DESC_PATH}"
        DYN_BUILD_DESC_PATH="$(mktemp)"

        #######################################################################
        # Write environment variables into dynamic build descriptor.

        # Print environment variables.
        env

        # TODO: Put repeated in-place Python script into a file instead
        #       of copying and pasting them.

        # In-place Python script. Write it into a file to be executed later.
        ENV_PYTHON_SCRIPT=$(mktemp)
        cat &lt;&lt;HEREDOC_MARKER &gt; ${ENV_PYTHON_SCRIPT}
import os
import sys
import yaml

# Load data from dynamic descriptor.
with open(sys.argv[1], 'r') as yaml_file:
    loaded_data = yaml.load(yaml_file)

# If file was empty, its data is None, but we need a dict.
if loaded_data is None:
    loaded_data = {}

# Capture environment variables in two formats:
# - Save environment variables as text with shell code.
loaded_data['environ_text'] = sys.stdin.read()
# - Save environment variables as dict structure.
loaded_data['environ'] = os.environ.copy()

# Save dynamic build descriptor.
with open(sys.argv[1], 'w') as yaml_file:
    yaml.dump(
        loaded_data,
        yaml_file,
        default_flow_style = False,
        indent = 4,
    )

HEREDOC_MARKER

        # Write output of env command into dynamic build descriptor.
        env | python ${ENV_PYTHON_SCRIPT} ${DYN_BUILD_DESC_PATH}

        #######################################################################
        # Write parameters to the file used by subsequent jobs.

        echo >> {{ job_environ['jenkins_dir_path'] }}/build.properties
        {% for param_name in job_config['build_parameters'].keys() %}
        echo "{{ param_name }}=${{ param_name }}" >> {{ job_environ['jenkins_dir_path'] }}/build.properties
        {% endfor %}

        #######################################################################
        # Make sure target bootstrap profile pillars repo is on required branch.

        # Get location of target bootstrap profile pillars repo.
        {% set project_name = pillar['project_name'] %}
        {% if pillar['is_generic_profile'] %}
        {% set repo_config = pillar['system_features']['deploy_environment_sources']['source_repositories'][project_name + '-salt-states']['git'] %}
        {% else %}
        {% set repo_config = pillar['system_features']['deploy_environment_sources']['source_repositories'][project_name + '-salt-pillars.bootstrap-target']['git'] %}
        {% endif %}

        TARGET_BOOTSTRAP_PROFILE_PILLARS_REPO_PATH='{{ get_system_host_primary_user_posix_home(repo_config['source_system_host']) }}/{{ repo_config['origin_uri_ssh_path'] }}'
        cd "${TARGET_BOOTSTRAP_PROFILE_PILLARS_REPO_PATH}"
        {% if not pillar['is_generic_profile'] %}
        git checkout ${TARGET_PROFILE_NAME}
        {% endif %}
        CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
        cd -

        test "$CURRENT_BRANCH" == "${TARGET_PROFILE_NAME}"

        #######################################################################
        # In-place Python script which captures stdin data under
        # specified key in destination dict.

        # TODO: Put repeated in-place Python script into a file instead
        #       of copying and pasting them.

        KEY_SETTER_PYTHON_SCRIPT=$(mktemp)
        cat &lt;&lt;HEREDOC_MARKER &gt; ${KEY_SETTER_PYTHON_SCRIPT}
import os
import sys
import yaml

# Load data from dynamic descriptor.
with open(sys.argv[1], 'r') as yaml_file:
    loaded_data = yaml.load(yaml_file)

# If file was empty, its data is None, but we need a dict.
if loaded_data is None:
    loaded_data = {}

# Parse specification of the key provided on command line.
# The format should be 'parent-key:child-key:...:sub-key'
key_spec = sys.argv[2]
key_list = key_spec.split(':')
last_sub_key = key_list[-1]
curr_value = loaded_data
# Walk down to the last dictionary where 'last_sub_key' is.
for curr_key in key_list[:-1]:
    if curr_key not in curr_value:
        curr_value[curr_key] = {}
    curr_value = curr_value[curr_key]
    assert(isinstance(curr_value, dict))

# Assign content of STDIN to the specified key.
curr_value[last_sub_key] = sys.stdin.read().strip()

# Save dynamic build descriptor.
with open(sys.argv[1], 'w') as yaml_file:
    yaml.dump(
        loaded_data,
        yaml_file,
        default_flow_style = False,
        indent = 4,
    )

HEREDOC_MARKER

        #######################################################################
        # Capture into dynamic build descriptor:
        # - build timestamp
        # - current branch names
        # - current commit ids
        # - build branch names
        # - status of local changes

        # NOTE: We assume that repository is available
        #       locally on Jenkins slave.

        # We assume that remote `origin` has to be pre-configured.
        # TODO: Use automation to use configured remote and probably branch.

        BUILD_TIMESTAMP="$(date "+%Y-%m-%dT%H-%M-%S")"
        SOURCE_PROFILE_NAME="${SALT_PROFILE_NAME}"
        BUILD_TITLE="${BUILD_VERSION_NUMBER}-${BUILD_NUMBER}-${BUILD_TIMESTAMP}-${SOURCE_PROFILE_NAME}-${TARGET_PROFILE_NAME}-${BUILD_TYPE}-${BUILD_LABEL}"

        {% for repo_name in pillar['system_features']['deploy_environment_sources']['source_repositories'].keys() %}
        {% set repo_config = pillar['system_features']['deploy_environment_sources']['source_repositories'][repo_name]['git'] %}
        REPO_PATH="{{ get_system_host_primary_user_posix_home(repo_config['source_system_host']) }}/{{ repo_config['origin_uri_ssh_path'] }}"

        cd "${REPO_PATH}"
        CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
        # HEAD value means that repository is at detached head.
        test "$CURRENT_BRANCH" != "HEAD"
        CURRENT_COMMIT_ID="$(git rev-parse --verify HEAD)"
        CURRENT_COMMIT_ID_SHORT="$(git rev-parse --short --verify HEAD)"
        BUILD_BRANCH_NAME="${CURRENT_BRANCH}-${CURRENT_COMMIT_ID_SHORT}-${BUILD_TITLE}"
        UNTRACKED_ITEMS="$(git ls-files --other --exclude-standard --directory | wc -l)"
        MODIFIED_ITEMS="$((git diff --name-only --cached --ignore-submodules=dirty ; git diff --name-only --ignore-submodules=dirty) | sort -u | wc -l)"
        cd -

        echo "$CURRENT_BRANCH"    | python ${KEY_SETTER_PYTHON_SCRIPT} ${DYN_BUILD_DESC_PATH} "initial_branches:{{ repo_name }}"
        echo "$CURRENT_COMMIT_ID" | python ${KEY_SETTER_PYTHON_SCRIPT} ${DYN_BUILD_DESC_PATH} "initial_commit_ids:{{ repo_name }}"
        echo "$BUILD_BRANCH_NAME" | python ${KEY_SETTER_PYTHON_SCRIPT} ${DYN_BUILD_DESC_PATH} "build_branches:{{ repo_name }}"
        echo "$UNTRACKED_ITEMS"   | python ${KEY_SETTER_PYTHON_SCRIPT} ${DYN_BUILD_DESC_PATH} "untracked_items:{{ repo_name }}"
        echo "$MODIFIED_ITEMS"    | python ${KEY_SETTER_PYTHON_SCRIPT} ${DYN_BUILD_DESC_PATH} "modified_items:{{ repo_name }}"

        {% endfor %}

        #######################################################################
        # Save dynamic build descriptor into workspace.
        #
        # We don't save it under repository yet as this would make additonal
        # local modifications. Instead, this file is saved in the workspace
        # to be copied by `init_build_branches` job (which eventually
        # saves it under build branch).
        cp "${DYN_BUILD_DESC_PATH}" dynamic_build_descriptor.yaml

      </command>
    </hudson.tasks.Shell>
  </builders>

  <publishers>

    <!--
        Archive and Fingerprint initial dynamic build descriptor.
        This is only needed to trace jobs of the same pipeline execution.
    -->
    <hudson.tasks.ArtifactArchiver>
      <artifacts>dynamic_build_descriptor.yaml</artifacts>
      <allowEmptyArchive>false</allowEmptyArchive>
      <onlyIfSuccessful>true</onlyIfSuccessful>
      <fingerprint>true</fingerprint>
      <defaultExcludes>true</defaultExcludes>
    </hudson.tasks.ArtifactArchiver>

    {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import parameterized_job_triggers_macro with context %}
    {{ parameterized_job_triggers_macro(job_config, job_environ) }}

  </publishers>

  <buildWrappers/>

</project>

