<?xml version='1.0' encoding='UTF-8'?>
<project>

  {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import common_job_configuration with context %}
  {{ common_job_configuration(job_config, job_environ) }}

  <builders>

    {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import copy_artifacts with context %}
    {{ copy_artifacts(job_config, job_environ) }}

    <hudson.tasks.Shell>
      <command>

        set -e
        set -u

        {% if 'skip_script_execution' in job_config and job_config['skip_script_execution'] %}
        exit 0
        {% endif %}

        {% if 'skip_if_true' in job_config %}
        if [ "${{ '{' }}{{ job_config['skip_if_true'] }}:-false}" == "true" ]
        then
            exit 0
        fi
        {% endif %}

        JOB_STATUS='stable'

        {% from 'common/libs/host_config_queries.sls' import get_system_host_primary_user_posix_home with context %}

        {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import locate_dynamic_build_descriptor with context %}
        {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import update_dynamic_build_descriptor with context %}

        {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import key_getter_python_script with context %}
        {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import key_setter_python_script with context %}

        #######################################################################
        # Locate dynamic build descriptor.

        {{ locate_dynamic_build_descriptor(job_config, job_environ) }}

        # At this point (before checking out required commits), we already
        # know that recovery would require at least checking out initial
        # commits and branches back. The initial commits and branches are
        # already written in the dyn build desc - use it as initial recovery descriptor.
        cp "${LATEST_DYN_BUILD_DESC_PATH}" "${RECOVERY_DYN_BUILD_DESC_PATH}"

        #######################################################################
        # In-place Python script which captures stdin data under
        # specified key in destination dict.

        KEY_SETTER_PYTHON_SCRIPT=$(mktemp)
        cat &lt;&lt;HEREDOC_MARKER &gt; ${KEY_SETTER_PYTHON_SCRIPT}
{{ key_setter_python_script(job_config, job_environ) }}
HEREDOC_MARKER

        #######################################################################
        # In-place Python script which returns data under
        # specified key in destination dict on stdout.

        KEY_GETTER_PYTHON_SCRIPT=$(mktemp)
        cat &lt;&lt;HEREDOC_MARKER &gt; ${KEY_GETTER_PYTHON_SCRIPT}
{{ key_getter_python_script(job_config, job_environ) }}
HEREDOC_MARKER

        #######################################################################
        # NOTE: The next series of steps may fail due to local changes.
        #       It is required behaviour - do not go futher with such local changes.
        #       In this case, recovery procedure simply has to check out
        #       everything back (whether it was successful, failed or yet untouched).

        #######################################################################
        # Checkout required branches at specific commmit ids.
        # This step requires both:
        # * list of names for the branches per repository in `required_branches`;
        # * list of commit ids these branches have to be set to in `required_commit_ids`;
        # otherwise required conditions cannot be reproduced.
        # 
        # In cases when this is not a rebuild, release or package, the step
        # is pretty dummy - it simply checks out repositories at the
        # same state they currently are.

        {% for repo_name in pillar['system_features']['deploy_environment_sources']['source_repositories'].keys() %}
        {% set repo_config = pillar['system_features']['deploy_environment_sources']['source_repositories'][repo_name]['git'] %}
        REPO_PATH="{{ get_system_host_primary_user_posix_home(repo_config['source_system_host']) }}/{{ repo_config['origin_uri_ssh_path'] }}"

        REQUIRED_BRANCH="$(python ${KEY_GETTER_PYTHON_SCRIPT} ${JOB_DYN_BUILD_DESC_PATH} "required_branches:{{ repo_name }}")"
        REQUIRED_COMMIT_ID="$(python ${KEY_GETTER_PYTHON_SCRIPT} ${JOB_DYN_BUILD_DESC_PATH} "required_commit_ids:{{ repo_name }}")"

        cd "${REPO_PATH}"
        git checkout -B "${REQUIRED_BRANCH}" "${REQUIRED_COMMIT_ID}"
        cd -

        {% endfor %}

        #######################################################################
        # Update all current branches, if requiested.
        # And record the new commits.

        # We assume that remote `origin` has to be pre-configured.
        # TODO: Use automation to use configured remote and probably branch.

        {% for repo_name in pillar['system_features']['deploy_environment_sources']['source_repositories'].keys() %}
        {% set repo_config = pillar['system_features']['deploy_environment_sources']['source_repositories'][repo_name]['git'] %}
        REPO_PATH="{{ get_system_host_primary_user_posix_home(repo_config['source_system_host']) }}/{{ repo_config['origin_uri_ssh_path'] }}"

        cd "${REPO_PATH}"
        CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
        # HEAD value means that repository is at detached head.
        test "$CURRENT_BRANCH" != "HEAD"
        git pull --ff-only origin $CURRENT_BRANCH
        CURRENT_COMMIT_ID="$(git rev-parse --verify HEAD)"
        cd -

        # NOTE: We do not need to update branch names as they stay the same.
        echo "$CURRENT_COMMIT_ID" | python ${KEY_SETTER_PYTHON_SCRIPT} ${JOB_DYN_BUILD_DESC_PATH} "updated_commit_ids:{{ repo_name }}"

        {% endfor %}

        #######################################################################
        # Update dynamic build descriptor.

        {{ update_dynamic_build_descriptor(job_config, job_environ) }}

        # One of the purposes of this job is to set recovery
        # dynamic build descriptor so that changes made to repositories
        # can be reverted to their state before this job.
        cp "${LATEST_DYN_BUILD_DESC_PATH}" "${RECOVERY_DYN_BUILD_DESC_PATH}"

        #######################################################################
        # Report status of the execution.

        {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import get_JENKINS_CLI_TOOL_INVOKE_STRING with context %}
        {{ get_JENKINS_CLI_TOOL_INVOKE_STRING(job_config, job_environ) }}

        if [ "${JOB_STATUS}" == 'unstable' ]
        then

            # Set build unstable.
            # See: http://stackoverflow.com/a/8822743/441652
            eval "${JENKINS_CLI_TOOL_INVOKE_STRING} set-build-result unstable"

        fi

        #######################################################################

      </command>
    </hudson.tasks.Shell>
  </builders>

  <publishers>

    {% from 'common/jenkins/configure_jobs_ext/common_xml_templates.lib.sls' import parameterized_job_triggers_macro with context %}
    {{ parameterized_job_triggers_macro(job_config, job_environ) }}

  </publishers>

  <buildWrappers/>

</project>

